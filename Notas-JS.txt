npm create vite
Coloco nombreProyecto
React
JavaScript
cd nombreProyecto
npm install
npm run dev
    Levanta un SERVIDOR de desarrollo en
        IP: localhost
        PUERTO: 5173 (por defecto)
    Abrirlo en el navegador

ELIMINAR DEL PROYECTO:
    -assets
    -App.css
    -App.jsx
    -index.css

Ir a main.jsx, borrar todo y escribir un Hello World! en un console log

# ==========================================
# INICIO de JavaScript
# ==========================================
Scope de variables: let o const 
    -> crean una variable en un scope determinado.
    -> puedo usar 2 variables con el mismo nombre en 2 scope distintos

Template Strings:
    const nombre = 'Agustin';
    const apellido = 'Brocani';
    const nombreCompleto = `${nombre} ${apellido}`;

Objetos literales(Diccionarios en otros lenguajes): trabajan con pares de valores Key-Value
    const persona = {};
    CUANDO CREO CUALQUIER COSA en js tiene un PROTOTYPE -> funciones, metodos, getters y setters
    , AL FINAL de props es BUENA PRÁCTICA
    En ECMAscript6 {persona} // estoy creando un nuevo objeto que tiene un key-value persona: persona -> ASI CONOZCO EL NOMBRE DEL Objetos
    Props se ordenan alfabeticamente por estandar de los navegadores
    Spread Operator(...):
    NO HACER const persona2 = persona; // COPIA REFERENCIA, si cambio valor de prop, cambie objeto original => usar OPERADOR spread para hacer copia real.

Arrays: colección de info en 1 variable
    const arreglo = new Array();    // array vacio
    const arreglo = new Array(100); // array 100 posiciones vacias
    arreglo.push(valor);    // agregar => NO USARLO, modifica el objeto principal, usar spread
    EJEMPLO DE CAMBIO:
    let arreglo2 = arreglo;
    arreglo2.push(5);   
    console.log(arreglo)    // [1,2,3,4,5]
    FORMA CORRECTA DE AGREGAR:
    const arreglo2 = [...arreglo, 5];
    FUNCIÓN map => es parte del prototype de los Array
    MAP crea un NUEVO ARRAY.
    const funcion = () => 'Para cada elemento, ejecuto esto';
    arreglo.map(funcion);   // funcion es una función de callback
    Si FUNCION NO TIENE return explícito => retorna undefined

Funciones
    NO USAR function para crear función => puedo pisar la referencia a la función => usar const y el nombre
    EJEMPLO:
        function saludar(nombre) {
            return `Hola ${nombre}`;
        };
        saludar = 30;
        console.log(saludar);
    Eso es válido.
    USAR:
    const saludar = function(nombre) {
        return `Hola ${nombre}`;
    };
    const saludar2 = (nombre) => {
        return `Hola ${nombre}`;
    };
    const saludar3 = (nombre) => `Hola ${nombre}`;
    Protip con arrow functions: usar () para ahorrarme el return cuando quiero que devuelva un bloque
    const getUser = () => ({
        uid: 'AB123',
        username: 'MiUserID'
    });
    VERSIÓN LARGA:
    const getUser = () => {
    return ({
        uid: 'AB123',
        username: 'MiUserID'
    })};

Desestructuración de objetos(asignación desestructurante):
    const persona = {
        nombre: 'Tony',
        edad: 45,
        clave: 'Ironman'
    };

    console.log(persona.nombre);
    console.log(persona.edad);
    console.log(persona.clave);
    ¡HACER ESO es MOLESTO! => uso asignación desestructurante
        const {nombre} = persona;
    Si quiero asignar otro alias => ya no puedo usar nombre para invocarlo, debo usar nombre2
        const {nombre: nombre2} = persona;
    Si quiero desestructurar más de 1 prop:
        const {nombre, edad, clave} = persona;
    Utilidad real:
        const retornarPersona = (persona) => {
            const {nombre, edad, clave} = persona;
            console.log(nombre, edad, clave);
        };
    USAR mejor: 
        const retornarPersona = ({nombre, edad, clave}) => {
            console.log(nombre, edad, clave);
        };
    IMPORTANTE: puedo asignar valores por defecto.
        const retornarPersona = ({nombre, edad, clave, rango = 'CEO'}) => {
            console.log(nombre, edad, clave, rango);    // Tony 45 Ironman CEO
        };
    SI EXISTE, usa el valor que recibe, SI NO EXISTE, asigna 'CEO' en lugar de undefined.
    const useContext = ({nombre, edad, clave, rango = 'CEO'}) => {
        return {
            nombreClave: clave,
            anios: edad,
            latlng: {
                lat: 14.1232,
                lng: -12.3232
            }
        };
    };
    const avenger = useContext(persona);
    ¿Qué pasa si existen N niveles de anidamiento y quiero desestructurar en variables?
        const { nombreClave, anios, latlng:{lat, lng} } = avenger;
    console.log(lat, lng);
    Si lo quiero más prolijo:
        const {nombreClave, anios, latlng} = avenger;
        const {lat, lng} = latlng;

Desestructuración de Arrays:
    const array = [1,2,3];
    const [valor1] = array;         // console.log(valor1); -> 1
    const [ , , valor3] = array;    // console.log(valor3); -> 3
    
    const useState = (valor) => {
        return [valor, () => {console.log('Hola Mundo')}];
    }
    const [, holaMundo] = useState('Goku');
    holaMundo();

    const useStateTarea = (nombre) => {
        return [nombre, () => console.log("Cambie el nombre " + nombre)];
    }
    const [nombre, setNombre] = useStateTarea('Agustin');
    console.log(nombre);

IMPORT, EXPORT, FIND, INDEXOF, FILTER:

    IMPORTANTE: cuando hago un IMPORT, se ejecuta TODO el archivo importado 1 vez.

    EXPORT-IMPORT INDIVIDUAL:
        Shortcut: imp + TAB
        export const algo = [];
        import { algo } from 'path donde esta algo'

    EXPORT-IMPORT PARA TODO EL ARCHIVO: NO LLEVA NOMBRE, el nombre lo coloco cuando hago el import
    export default [e1, e2, e3];    // NO LLEVA NOMBRE
    import algo from 'path donde esta algo'

    EXPORT-IMPORT MIXTO:
        export {
            heroes as default,
            owners
        }
        import heroes, { owners } from 'path donde esta algo'

    FUNCION DE CALLBACK:
        (elemento, indice, array) => {return algo;}

    FUNCIÓN FIND: Devuelve el primer elemento del array que cumple con la condición indicada por una función
        const algo = valorQueQuieroMatchear;
        const fCallback = (elemento) => elemento == algo; 
        heroes.find(fCallback)
            Devuelve el 1er ELEMENTO que cumple la condición.
        heroes.findIndex(fCallback)
            Devuelve el 1er INDICE que cumple la condicion => USAR CON OBJETOS, yo le digo como comparar

    FUNCIÓN INDEXOF: Devuelve el índice del primer elemento exactamente igual (===) al valor buscado.
        const variableABuscar = valor;
        heroes.indexOf(variableABuscar)
            Devuelve el 1er INDICE que ES IGUAL al VALOR PASADO POR PARÁMETRO.
            const objetoHeroe = { id: 2, name: 'Spiderman', owner: 'Marvel' };
            const indiceHeroe = heroes.indexOf(objetoHeroe);
            console.log(indiceHeroe);   // -1 => NO EXISTE, compara REFERENCIAS porque son OBJETOS

    FUNCIÓN FILTER: Devuelve un nuevo array con todos los elementos que cumplen con la condición.
        heroes.filter((h) => h.id === id)   // [h1, h2, h3] siendo h1, h2, h3 objetos heroe que cumplen la condición

    RESUMEN:
        .filter                     !=      .find
        Array de N Objetos o []             1 Objeto o undefined

        findIndex                   !=          indexOf
        Recibe una funcion de callback          Recibe lo que quiero buscar
        Le digo como comparar                   Compara por valor
        USAR CON OBJETOS                        USAR CON TIPOS BÁSICOS

Promesas:
    Una Promise está en uno de estos estados:
        pending     (pendiente) : estado inicial, ni cumplido ni rechazado.
        fulfilled   (cumplida)  : lo que significa que la operación se completó con éxito.
        rejected    (rechazada) : lo que significa que la operación falló.

        const promesa = new Promise(callback);
            callback: funcion que se ejecuta en algún momento y se pasa por parámetro a otra función.

        const callback = (resolve, reject) => {
            // resolve  : callback que se ejecuta cuando la promesa es exitosa
            // reject   : callback que se ejecuta cuando la promesa falla
        };
    
    setTimeout: ejecuta callback cada X tiempo en milisegundos
        setTimeout(callback, tiempoEnMs);

    EJECUTAR ACCIONES cuando Promise pase de pending a fullfilled o rejected

    .then       => se ejecuta si la promesa esta en estado fulfilled
    .catch      => se ejecuta si la promesa esta en estado rejected
    .finally    => algo que se ejecuta SI o SI despues del then/catch

    IMPORTANTE: si NO UTILIZO resolve() y reject() dentro del CALLBACK de la Promise => NO VOY A CAPTAR NADA EN EL THEN ni en el CATCH

    RESUMEN:
        -resolve y reject por convención.
        -si no invoco a resolve y reject, then y catch no atrapan nada.
        -si quiero utilizar parametros dentro de una promesa, englobo promesa en funcion que es async
        -Llamado: funcionAsync(parametroAMandar)
            .then(callbackThen)
            .catch(callbackCatch)
            .finally(callabackFinally);

        const funcionAsync = (parametroAMandar) => {
            const callback = (resolve, reject) =>{
                const resultado = operacion(parametroAMandar);
                if (!resultado) {
                    reject('Mensaje de error');
                }
                resolve(resultado);
            };
            return new Promise(callback);
        }

        ¿Que pasa si operacion puede fallar? => uso try-catch
        const funcionAsync = (parametroAMandar) => {
            const callback = (resolve, reject) =>{
                try {
                    const resultado = operacion(parametroAMandar);
                    resolve(resultado);
                } catch (err) {
                    reject('Mensaje de error ' + err);
                }
            };
            return new Promise(callback);
        }

    DOCUMENTACIÓN: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

fetch: es una función nativa de JavaScript (desde ES6) que se usa para hacer solicitudes HTTP/HTTPS desde el navegador.
    Recibe 2 parametros
        url         => string, es importante que tenga bien el HTTP o HTTPS
        opciones    => objeto de configuración
    RETORNA Promise
    IMPORTANTE: ¡NO SE RECHAZA la Promise por ERRORES HTTP!, porque tuve respuesta.
        => debo manejarlo con resp.ok o resp.status

    Ejemplo con 1 parametro[Hace GET basico por defecto]
    fetch(url).then(resp => {
    console.log(resp.status); // 200, 404, 500, etc.
    console.log(resp.ok);     // true si status está entre 200 y 299
    console.log(resp.headers); // Headers de la respuesta
    });

    Ejemplo con opciones:
    fetch('https://api.ejemplo.com/usuarios', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer token123'
        },
        body: JSON.stringify({ nombre: 'Agustin' })
    });

    Propiedad	¿Qué hace?
    method	    HTTP method: 'GET', 'POST', 'PUT', etc.
    headers	    Cabeceras HTTP como Content-Type, Accept
    body	    Cuerpo de la solicitud (JSON, texto, etc.)
    mode	    'cors', 'no-cors', 'same-origin'
    credentials	'include', 'omit', 'same-origin' (cookies)
    cache	    Controla el caché: 'no-cache', 'reload', etc.

Object.values(algo) => convierte objeto de objetos en array de objetos

async-await:
    async: clausula que automáticamente convierte el retorno en una Promise
    await: clausula, usada dentro de una funcion async, para esperar que una promesa se resuelva antes de seguir ejecutando el código
    ERRORES se manejan con try-catch dentro de la funcion async

then-catch vs async-await:
    Hacer .then concatenados es equivalente a tener varios await
        [Se espera a que se resuelva un .then para resolver el siguiente]
    Usar 1 solo .catch es quivalente al catch del try-catch en async-await

Operador ternario
    SI QUIERO AMBAS PARTES:
    const mensaje = activo ? 'Activo' : 'Inactivo';
    
    QUIERO EJECUTAR SOLO 1 PARTE:
        Como NO HACERLO
            const mensaje = activo ? 'Activo' : null;
        COMO HACERLO
            const mensaje = activo && 'Activo';
    
    RESULTADO:
    // Se ve por consola 'Activo' si activo es true y false si activo es false
    console.log(mensaje);   // EQUIVALENTE => activo ? 'Activo' : false;

REPO DE JavaScript: https://github.com/Klerith/react-intro-javascript
# ==========================================
# FIN de JavaScript
# ==========================================
